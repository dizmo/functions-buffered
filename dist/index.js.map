{"version":3,"sources":["index.js"],"names":[],"mappings":"AAAA;;AACA,OAAO,cAAP,CAAsB,OAAtB,EAA+B,YAA/B,EAA6C,EAAE,OAAO,IAAT,EAA7C;AACA;;;;;;;;;;;;;AAaA,SAAS,QAAT,CAAkB,EAAlB,EAAgC;AAAA,QAAV,EAAU,uEAAL,GAAK;;AAC5B,QAAI,WAAJ;AAAA,QAAQ,WAAW,SAAX,QAAW,GAAmB;AAAA;;AAAA,0CAAN,IAAM;AAAN,gBAAM;AAAA;;AAClC,eAAO,IAAI,OAAJ,CAAY,mBAAW;AAC1B,yBAAa,EAAb;AACA,iBAAK,WAAW;AAAA,uBAAM,QAAQ,GAAG,KAAH,CAAS,KAAT,EAAe,IAAf,CAAR,CAAN;AAAA,aAAX,EAAgD,EAAhD,CAAL;AACH,SAHM,CAAP;AAIH,KALD;AAMA,aAAS,MAAT,GAAkB,YAAM;AACpB,qBAAa,EAAb;AACH,KAFD;AAGA,WAAO,QAAP;AACH;AACD,QAAQ,QAAR,GAAmB,QAAnB;AACA,QAAQ,OAAR,GAAkB,QAAlB","file":"index.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a buffered and cancelable version for the provided function.\n *\n * The buffered function does *not* get invoked before the specified delay in\n * milliseconds passes, no matter have many times it gets invoked in between.\n * Also upon the invocation of the *buffering* function a promise is returned.\n * Further, it is also possible to *cancel* a particular invocation before the\n * delay passes.\n *\n * @param fn an arbitrary function\n * @param ms delay in milliseconds\n * @returns a buffered function (returning a promise)\n */\nfunction buffered(fn, ms = 200) {\n    let id, buffered = function (...args) {\n        return new Promise(resolve => {\n            clearTimeout(id);\n            id = setTimeout(() => resolve(fn.apply(this, args)), ms);\n        });\n    };\n    buffered.cancel = () => {\n        clearTimeout(id);\n    };\n    return buffered;\n}\nexports.buffered = buffered;\nexports.default = buffered;\n"]}